#### 一，MySQL数据类型

##### (1) 整数类型: tinyint/smallint/mediumint/int/bigint 

属性: unsigned

长度: 可以为整数类型指定宽度，例如:int(11)、对大多数应用是没有意义的，他不会限制值的合法范围，只会影响显示字符的个数。

zerofill: 指定int(3) 存储12时会显示012,可存储1234

##### (2) 实数类型: float/double/decimal

- decimal可以存储比bigint还要大的整型，可以用于存储精确的小数;

- float/double支持使用标准浮点进行近似计算

##### (3) 字符串类型: varchar/char/text/blob

- varchar：可用于存储可变长字符串，他比定长类型更节省空间;varchar使用1或者2个额外字节记录字符串的长度，列长度小于255字节，使用1个字节表示，否则用2个；如果存储长度超出指定长度会被截断

- char: 定长的，会根据定义的字符串长度分配足够的空间;char会根据需要采用空格进行填充以方便比较；适合存储很短的字符串，或者所有值都接近同一个长度(存储密码);超出指定长度会被截断

- 对于经常变更的数据char比varchar更好，char不容易产生碎片

- 对于非常长短的列，char比varchar在存储空间上更有效率
- 只分配真正需要的空间，更长的列会消耗更多的内存
- 尽量避免使用text和blob类型，查询会使用临时表，导致严重的性能消耗

##### (4) 枚举

- 有时可以使用枚举来代替常用的字符串类型；
- 把不重复的集合存储成一个预定义的集合；(存储男女)
- 非常紧凑，把列表值压缩到一个或两个字节
- 内部存储的是整数

##### (5) 日期时间类型

- 尽量使用timestamp,比datetime空间效率高;
- 用整数保存时间戳的格式通常不太方便处理;
- 如果需要存储微秒，可以使用bigint存储;

##### (6) 列属性

```
auto_increment\default\not null\zerofill
```

#### 二，MySQL基础操作

连接关闭:
```
mysql -u -p -h -P
```

\G,\d....

#### 三，MySQL基础引擎

##### (1) InnoDB表引擎

- 默认事务性引擎，最重要最广泛的存储引擎，性能非常优秀;
- 数据存储在共享表空间，可通过配置分开;
- 对主键查询的性能高于其他类型的存储引擎；
- 内部做了很多优化，从磁盘读取数据时自动在内存构建hash索引，插入数据时自动构建插入缓冲区；
- 通过一些机制和工具支持真正的热备份；
- 支持崩溃后的安全恢复；
- 支持行级锁；
- 支持外健

##### (2) MyISAM

- 5.1版本前，MyISAM是默认的存储引擎；
- 拥有全文索引、压缩、空间函数；
- 不支持事务和行级锁，不支持崩溃后的安全恢复；
- 表存储在两个文件，MYD和MYI
- 表级锁；
- 设计简单，某些场景下性能很好；(select *等)

##### (3) 其他表引擎

```
Archive、Blackhole、CSV、Memory等
```

#### 四，MySQL锁机制

> 当多个查询同时进行数据修改时，就会产生并发控制的问题。

##### (1) 读锁

共享的，不阻塞，多个用户可以同时读取一个资源，互不干扰；

##### (2) 写锁

排他的，一个写锁会阻塞其他的读锁和写锁，这样可以只允许一个人进行写入，防止其他用户读取正在写入的资源；

##### (3) 锁粒度

- 表锁，系统性能开销最小，会锁定整张表，MyISAM使用表锁;
- 行锁，最大程度的支持并发处理，但是也带来了最大的锁开销，InnoDB支持行级锁;

#### 五，MySQL事务处理、存储过程、触发器

##### (1) 事务处理

- MySQL提供事务处理的表引擎，InnoDB
- 服务器层不管理事务，由下层的引擎实现，所以同一个事务中，使用多种存储引擎不靠谱；
- 在非事务的表上执行事务操作mysql不会发出提醒，也不会报错；

##### (2) 存储过程

- 为以后的使用而保存的一条或多条mysql语句的集合;
- 存储过程就是有业务逻辑和流程的集合;
- 可以在存储过程中创建表、更新数据、删除等；

使用场景：

- 通过把处理封装在容易使用的单元中，简化复杂的操作；
- 保证数据的一致性；
- 简化对变动的管理；

##### (3) 触发器

> 提供给程序员和数据分析员来保证数据完整性的一种方法，他是与表事件相关的特殊的存储过程；

使用场景：

- 可通过数据库中的相关表实现级联更改；
- 实时监控某张表中的某个字段的更改而需要做出相应的处理；
- 某些业务编号的生成等等；
- 滥用会造成数据库及应用程序的维护困难；

---

#### 一，创建mysql高性能索引

#### 1, 索引基础

索引类似于书的目录，要想找到书的某一个特定主题，要先找到书的目录，定位对应的页码。

存储索引使用类似的方法查找数据，先去索引中找到对应的值，再去根据匹配的索引查找对应的数据行。

#### 2, 索引对性能的影响

- 大大减少服务器需要扫描的数据量。
- 帮助服务器避免排序和临时表。
- 将随机I/O变成顺序I/O。
- 大大提高查询速度，降低写的速度，占用磁盘。

#### 3, 索引的使用场景

- 对于非常小的表，大部分情况下全表扫描效率更高。
- 中到大型表，索引非常有效。
- 特大型的表，建立和使用索引的代价将随之增长，可以使用分区技术来解决。

#### 4, 索引的类型

索引有很多种类型，都是实现在存储引擎层的。

- 普通索引：最基本的索引，没有任何约束限制。
- 唯一索引：与普通索引类似，但是具有唯一性约束。
- 主键索引：特殊的唯一索引，不允许有空值。
- 组合索引：将多个列组合在一起创建索引，可以覆盖多个列。
- 外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。
- 全文索引：MySQL自带的全文索引只能用于MyISAM，并且只能对英文进行全文检索。

#### 5, 索引的区别

- 一张表只能有一个主键索引，可以有多个唯一索引；
- 主键索引一定是唯一索引，唯一索引不是主键索引；
- 主键可以与外键构成参照完整性约束，防止数据不一致；

#### 6, mysql索引创建的原则

- 1，最适合索引的列是出现在where子句中的列，或连接子句中的列，而不是出现在select关键字后的列；
- 2，索引列的基数越大，索引效果越好；
- 3，对字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间；
- 4，根据情况创建符合索引，符合索引可以提高查询效率；
- 5，避免创建过多索引，索引会额外占用磁盘空间，降低写操作效率；
- 6，主键尽可能选择较短的数据类型，可以有效的减少索引的磁盘占用，提高查询效率；

#### 7, mysql索引的注意事项

- 复合索引遵循前缀原则；(KEY(abc)  where a = 1 and b = 2 and c = 3生效 where b = 2 and c = 3不生效)
- like查询不能在前，索引失效，可以使用全文索引来解决
- column is null 可以使用索引
- 如果mysql估计使用索引会比全表扫描慢，会放弃使用索引
- 如果or之前的条件中列有索引，后面的没有，索引都不会被用到
- 列类型是字符串，查询时一定要给值加引号，否则索引失效

---

#### 一，mysql语句编写

##### 1，关联更新update

```sql
update A,B set A.c1 = B.c1,A.c2 = B.c2 where A.id = B.id;
```

```sql
update A inner join B on A.id = B.id set A.c1 = B.c1,A.c2 = B.c2 where ...
```

##### 2, 关联查询

> 6中关联查询：交叉关联(cross join)、内连接(inner join)、外连接(left join/right join)、联合查询(union/union all)、全连接(full join)

> 交叉连接

```
select * from A,B(,C);
select * from A cross join B (cross join C);
```

> 内连接何以缩写为join

```
select * from A,B where A.id = B.id;
select * from A inner join B on A.id = B.id;
```

> 外连接

left join以左表为主，查询出左表再匹配右表，right join则相反

> 联合查询

```
select * from A union select * from B union ...
```

> 全连接

mysql不支持全连接；可以使用left join和union和right join联合使用

```
select * from A left join B on A.id = B.id union select * from A right join B on A.id = B.id;
```

> 嵌套查询

使用一条语句的结果作为另一条查询语句的条件

```
select * from A where id in (select id from B);
```